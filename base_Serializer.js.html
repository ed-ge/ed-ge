<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: base/Serializer.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: base/Serializer.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import GameObject from "./GameObject.js"
import Point from "./Point.js"


class Serializer {
  constructor(components, prefabs) {
    this.components = components;
    this.prefabs = {};
    //this.prefabs = prefabs;
  }
  serializeComponent(component) {
    let toReturn = component.constructor.name;

    Object.keys(component).filter(i => i != 'gameObject' &amp;&amp; i != 'uuid').forEach(i => toReturn += ("|" + i + "|" + component[i]));
    return toReturn;
  }
  deserializeComponent(string) {
    let splits = string.split("|");
    let type = splits[0];
    let componentType = this.components[type]
    let component = new componentType();
    for (let i = 1; i &lt; splits.length; i += 2) {
      let key = splits[i];
      let value = splits[i + 1];
      component[key] = value;
    }
    return component;
  }
  serializeGameObject(gameObject) {
    let toReturn = {
      def: `${gameObject.name},${gameObject.x},${gameObject.y},${gameObject.scaleX},${gameObject.scaleY},${gameObject.rotation},${gameObject.prefabName}`,
      components: [],
      componentValues: [],
      children: []
    }

    for (let i = 0; i &lt; gameObject.components.length; i++) {
      let component = gameObject.components[i];
      let toAdd = this.serializeComponent(component);
      toReturn.components.push(toAdd);
    }
    //Now call the function on the children
    for (let i = 0; i &lt; gameObject.children.length; i++) {
      let child = gameObject.children[i];
      let toAdd = this.serializeGameObject(child);
      toReturn.children.push(toAdd);
    }
    return toReturn;
  }
  deserializePrefab(string, store = false, parent = null) {

    let lines = string.split(/\r?\n/);
    lines = lines.filter(l => l.trim().length > 0);

    let lineIndex = 0;
    //Read name and prefab line
    let nameLine = lines[lineIndex]
    let nameLineSplit = nameLine.split(/\s/);
    let name = nameLineSplit[0];
    let prefabName = nameLineSplit[1];

    let toReturn = new GameObject();
    if (prefabName != "Empty") {
      let toClone = this.prefabs[prefabName];
      toReturn = _.cloneDeep(toClone);//JSON.parse(JSON.stringify(toClone));
    }

    toReturn.name = name;
    toReturn.prefabName = prefabName;

    //Check to see if we have any tranformation information
    let possibleTranslateLine = lines[lineIndex + 1];
    //For floating point regex, see https://www.regular-expressions.info/floatingpoint.html
    if (possibleTranslateLine &amp;&amp; possibleTranslateLine.match(/^\s*[-+]?[0-9]*\.?[0-9]+,\s*[-+]?[0-9]*\.?[0-9]+\s*$/)) {
      // console.log("Found transform " + possibleTranslateLine)
      let split = lines[++lineIndex].trim().split(",");
      toReturn.x = +split[0].trim();
      toReturn.y = +split[1].trim();

      let possibleScaleLine = lines[lineIndex + 1];
      if (possibleScaleLine &amp;&amp; possibleScaleLine.match(/^\s*[-+]?[0-9]*\.?[0-9]+,\s*[-+]?[0-9]*\.?[0-9]+\s*$/)) {
        // console.log("Found scale " + possibleScaleLine)
        let split = lines[++lineIndex].trim().split(",");
        toReturn.scaleX = +split[0].trim();
        toReturn.scaleY = +split[1].trim();

        let possibleRotateLine = lines[lineIndex + 1];
        if (possibleRotateLine &amp;&amp; possibleRotateLine.match(/^\s*[-+]?[0-9]*\.?[0-9]+\s*$/)) {
          // console.log("Found rotate " + possibleRotateLine)
          lineIndex++;
          toReturn.scaleY = +possibleRotateLine.trim();
        }
      }
    }

    let currentComponent;
    while (++lineIndex &lt; lines.length) {
      let currentLine = lines[lineIndex].trimEnd();

      if (currentLine.length == 0) continue;
      if (currentLine.match(/^\s/)) {
        //It's a component value
        let componentValueSplit = currentLine.trim().split("=");
        let key = componentValueSplit[0]
        let value = componentValueSplit[1];
        //Look for JSON-like values
        if(value.startsWith("{") || value.startsWith("["))
          value = JSON.parse(componentValueSplit[1]);
        currentComponent[key] = value;
      }
      else {
        //It's a new component
        let componentName = currentLine.trim();
        if (toReturn.anyComponent(componentName)) {
          //Edit the existing componentent
          currentComponent = toReturn.getComponent(componentName);
        }
        else {
          //Add a new component
          currentComponent = new this.components[componentName]();
          toReturn.addComponent(currentComponent);
        }
      }
    }



    if (store)
      this.prefabs[name] = toReturn;
    if (parent != null) {
      // parent.children.push(toReturn);
      parent.addChild(toReturn);
      if (parent.newChildEvent)
        parent.newChildEvent(toReturn);
    }
    return toReturn;

  }
  instantiate(gameObjectType, location, scale = new Point(1, 1), rotation = 0, parent = this, obj = null) {
    let gameObject = this.deserializePrefab(gameObjectType, false, parent);
    gameObject.x = location.x;
    gameObject.y = location.y;
    gameObject.scaleX = scale.x;
    gameObject.scaleY = scale.y;
    gameObject.rotation = rotation;
    return gameObject;
    // let gameObject = new GameObject(location.x, location.y, scale.x, scale.y, rotation, gameObjectType.name);


    // let prefab = this.prefabs[gameObjectType.name];
    // this.buildIt(prefab, gameObject)
    // if (obj)
    //   gameObject.name = obj.name;
    // else
    //   gameObject.name = prefab.name;
    // gameObject.prefabName = gameObjectType.name;
    // if (obj) {
    //   this.buildIt(obj, gameObject)
    // }

    // if (parent) {
    //   parent.children.push(gameObject);
    //   if (parent.newChildEvent) {
    //     parent.newChildEvent(gameObject);
    //   }
    // }
    // gameObject.recursiveCall("start");

    // return gameObject;

  }

  buildIt(obj, gameObject) {
    //Recursively build children
    if (obj.children) {
      obj.children.forEach(i => this.deserializeGameObject(i, gameObject))
    }

    if (obj.add) obj.components = obj.add; //let add be shorthand for components
    if (obj.components) {
      obj.components.forEach(i => {
        let component = this.deserializeComponent(i);
        gameObject.addComponent(component);
      });
    }

    //Set the key-pair values on components already on prefabs
    if (obj.edit) obj.componentValues = obj.edit; //let edit be shorthand for componentValues
    if (obj.componentValues) {
      obj.componentValues.forEach(j => {
        let split = j.split("|").map(i => i.trim());
        let component = gameObject.getComponent(split[0])
        let value = split[2];
        try {
          value = JSON.parse(split[2])
        } catch (e) {
          //Looks like it wasn't JSON after all..
        }
        component[split[1]] = value;
      })
    }

    //Add new components

  }

  /**
   * 
   * @param {String} obj The string giving the declarative syntax
   * @param {NameableParent} parent The parent of the object in the scene tree
   */
  deserializeGameObject(obj, parent = null) {

    if (obj.new) obj.def = obj.new; //Add new as a shorthand for def
    if (obj.def) {
      obj.location = { x: 0, y: 0 };
      obj.scale = { x: 1, y: 1 };
      let split = obj.def.split(",").map(i => i.trim());
      switch (split.length) {
        case 1:
          obj.type = split[0];
          obj.name = obj.type;
          break;
        case 2:
          [obj.name, obj.type] = split;
          break;
        case 3:
          throw "There is no shorthand object definition with 3 values.";
        case 4:
          [obj.name, obj.location.x, obj.location.y, obj.type] = split;
          break;
        case 5:
          [obj.name, obj.location.x, obj.location.y, obj.scale.x, obj.type] = split;
          obj.scale.y = obj.scale.x;
          break;
        case 6:
          [obj.name, obj.location.x, obj.location.y, obj.scale.x, obj.scale.y, obj.type] = split;
          break;
        case 7:
          [obj.name, obj.location.x, obj.location.y, obj.scale.x, obj.scale.y, obj.rotation, obj.type] = split;
          break;
        default:
          throw "There is not a shorthand object definition with " + split.length + " arguments.";
      }
    }

    let gameObjectType = this.prefabs["" + obj.type]
    if (gameObjectType == null)
      throw "Could now find game object of type " + obj.type;

    obj.location = obj.location || { x: 0, y: 0 }
    obj.scale = obj.scale || { x: 1, y: 1 }
    obj.rotation = obj.rotation || 0;

    obj.location.x = +obj.location.x;
    obj.location.y = +obj.location.y;
    obj.scale.x = +obj.scale.x;
    obj.scale.y = +obj.scale.y;
    obj.rotation = +obj.rotation;

    return this.instantiate(gameObjectType, new Point(obj.location.x, obj.location.y), new Point(obj.scale.x, obj.scale.y), obj.rotation, parent, obj);

    //gameObject.name = obj.name;
    //this.buildIt(obj, gameObject);
  }

}

export default Serializer;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AABBCollider.html">AABBCollider</a></li><li><a href="Behavior.html">Behavior</a></li><li><a href="CameraComponent.html">CameraComponent</a></li><li><a href="CanvasComponent.html">CanvasComponent</a></li><li><a href="Component.html">Component</a></li><li><a href="ConvexCollider.html">ConvexCollider</a></li><li><a href="GameObject.html">GameObject</a></li><li><a href="Line.html">Line</a></li><li><a href="NameableParent.html">NameableParent</a></li><li><a href="Point.html">Point</a></li><li><a href="RectTransform.html">RectTransform</a></li><li><a href="Scene.html">Scene</a></li><li><a href="Time.html">Time</a></li><li><a href="TriangleCollider.html">TriangleCollider</a></li></ul><h3>Global</h3><ul><li><a href="global.html#main">main</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Sun Jul 05 2020 01:55:50 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
